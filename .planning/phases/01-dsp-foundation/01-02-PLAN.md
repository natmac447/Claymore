---
phase: 01-dsp-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - Source/dsp/fuzz/FuzzCore.h
  - Source/dsp/fuzz/FuzzTone.h
  - Source/dsp/fuzz/FuzzConfig.h
  - Source/dsp/fuzz/FuzzType.h
  - Source/dsp/ClaymoreEngine.h
  - Source/dsp/ClaymoreEngine.cpp
  - Source/dsp/OutputLimiter.h
autonomous: true
requirements:
  - DIST-01
  - DIST-02
  - DIST-03
  - DIST-04
  - DIST-05
  - DIST-06
  - SIG-05

must_haves:
  truths:
    - "FuzzCore processSample produces distortion with drive, symmetry, tightness, and sag parameters"
    - "FuzzTone applyTone applies low-pass filter at 2-20 kHz range and presence shelf at +/-6 dB"
    - "ClaymoreEngine processes audio through the complete DSP chain: gate -> oversample up -> fuzz -> oversample down -> tone"
    - "Noise gate with hysteresis opens and closes at different thresholds to prevent chatter"
    - "OutputLimiter wraps juce::dsp::Limiter for brickwall limiting"
  artifacts:
    - path: "Source/dsp/fuzz/FuzzCore.h"
      provides: "Per-sample waveshaping with drive, symmetry, tightness, sag"
      contains: "processSample"
    - path: "Source/dsp/fuzz/FuzzTone.h"
      provides: "Tone LPF (2-20 kHz) and Presence shelf (+/-6 dB at 4 kHz)"
      contains: "applyTone"
    - path: "Source/dsp/ClaymoreEngine.h"
      provides: "Complete DSP chain: gate, oversampling, fuzz, tone"
      exports: ["ClaymoreEngine"]
    - path: "Source/dsp/ClaymoreEngine.cpp"
      provides: "ClaymoreEngine implementation with prepare(), process(), getLatencyInSamples()"
      contains: "processSamplesUp"
    - path: "Source/dsp/OutputLimiter.h"
      provides: "Brickwall limiter wrapper around juce::dsp::Limiter"
      contains: "juce::dsp::Limiter"
  key_links:
    - from: "Source/dsp/ClaymoreEngine.cpp"
      to: "Source/dsp/fuzz/FuzzCore.h"
      via: "FuzzCore::processSample() called in oversampled loop"
      pattern: "FuzzCore::processSample"
    - from: "Source/dsp/ClaymoreEngine.cpp"
      to: "Source/dsp/fuzz/FuzzTone.h"
      via: "FuzzTone::applyTone() called after downsampling"
      pattern: "tone\\.applyTone"
    - from: "Source/dsp/ClaymoreEngine.cpp"
      to: "Source/dsp/fuzz/FuzzConfig.h"
      via: "FuzzConfig::mapDrive() and outputCompensation"
      pattern: "FuzzConfig::mapDrive"
---

<objective>
Port the proven Rat DSP from GunkLord and build the ClaymoreEngine signal chain wrapper with noise gate (hysteresis), 2x oversampling, and output limiter. This plan creates all the DSP classes that processBlock will drive.

Purpose: The core audio processing must exist before the PluginProcessor can wire parameters to it. These classes encapsulate all distortion, tone-shaping, gating, and limiting behavior.
Output: Compilable DSP classes ready to be instantiated and called from processBlock.
</objective>

<execution_context>
@/Users/nathanmcmillan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanmcmillan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dsp-foundation/01-CONTEXT.md
@.planning/phases/01-dsp-foundation/01-RESEARCH.md
@.planning/phases/01-dsp-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port fuzz DSP files from GunkLord with Claymore range extensions</name>
  <files>
Source/dsp/fuzz/FuzzCore.h
Source/dsp/fuzz/FuzzTone.h
Source/dsp/fuzz/FuzzConfig.h
Source/dsp/fuzz/FuzzType.h
  </files>
  <action>
Copy three files VERBATIM from GunkLord to Claymore:
- `/Users/nathanmcmillan/Projects/gunklord/source/dsp/fuzz/FuzzCore.h` -> `Source/dsp/fuzz/FuzzCore.h`
- `/Users/nathanmcmillan/Projects/gunklord/source/dsp/fuzz/FuzzType.h` -> `Source/dsp/fuzz/FuzzType.h`

For FuzzConfig.h: The file does not exist separately in GunkLord. FuzzType.h contains the FuzzConfig namespace. Create `Source/dsp/fuzz/FuzzConfig.h` with the same FuzzConfig namespace content as FuzzType.h (mapDrive, outputCompensation constants). This gives a clean include for ClaymoreEngine while maintaining FuzzType.h for FuzzCore.h's include chain.

For FuzzTone.h: Copy from `/Users/nathanmcmillan/Projects/gunklord/source/dsp/fuzz/FuzzTone.h` with ONE targeted change:
- Find the Tone LPF cutoff mapping line (approximately `const float cutoff = 800.0f + tone * 7200.0f;`)
- Change to: `const float cutoff = 2000.0f + tone * 18000.0f;` (maps 0-1 to 2000-20000 Hz per CONTEXT.md)
- Everything else in FuzzTone.h is UNCHANGED. Do NOT modify Presence shelf (+/-6 dB at 4 kHz) or DC blocker (20 Hz).

**Critical anti-pattern:** Do NOT modify FuzzCore.h logic. The per-sample waveshaping is verified-working. The Tightness HPF range change (20-800 Hz) happens at the CALL SITE in ClaymoreEngine, not inside FuzzCore.h. FuzzCore.h uses `state.tightnessFilter.setCutoffFrequency()` which is called externally.

Update include guards or `#pragma once` as needed. Ensure includes reference `<juce_dsp/juce_dsp.h>` and `<juce_core/juce_core.h>` only (no GunkLord-specific paths).
  </action>
  <verify>
    <automated>cd /Users/nathanmcmillan/Projects/Claymore && ls -la Source/dsp/fuzz/*.h && grep -c "processSample" Source/dsp/fuzz/FuzzCore.h && grep "2000.0f" Source/dsp/fuzz/FuzzTone.h</automated>
    <manual>All four fuzz headers exist; FuzzCore is unmodified; FuzzTone has the 2000-20000 Hz range</manual>
  </verify>
  <done>Four fuzz DSP headers in Source/dsp/fuzz/ with FuzzTone.h Tone range extended to 2000-20000 Hz; FuzzCore.h logic unmodified from GunkLord</done>
</task>

<task type="auto">
  <name>Task 2: Create ClaymoreEngine with noise gate hysteresis, 2x oversampling, and OutputLimiter</name>
  <files>
Source/dsp/ClaymoreEngine.h
Source/dsp/ClaymoreEngine.cpp
Source/dsp/OutputLimiter.h
  </files>
  <action>
**ClaymoreEngine.h/.cpp** — Based on GunkLord's FuzzStage.h as template:

Public interface:
- `void prepare(const juce::dsp::ProcessSpec& spec)` — initialize all DSP at correct rates
- `void process(juce::AudioBuffer<float>& buffer)` — full signal chain
- `float getLatencyInSamples() const` — returns oversampling latency
- Setter methods: `setDrive(float)`, `setSymmetry(float)`, `setTightness(float)`, `setSag(float)`, `setTone(float)`, `setPresence(float)`, `setGateEnabled(bool)`, `setGateThreshold(float)` (plus hidden gate params: `setGateAttack`, `setGateRelease`, `setGateRatio`, `setGateSidechainHPF`, `setGateRange`, `setGateHysteresis`)

Private members:
- `juce::dsp::Oversampling<float> oversampling` — 2 channels, 1x order (2x factor), IIR halfband polyphase, compensated latency
- `FuzzCoreState coreState[maxChannels]` where `maxChannels = 8`
- `FuzzTone tone` — runs at original sample rate (NOT oversampled)
- `juce::SmoothedValue<float>` for drive, symmetry, tightness, sag — reset at oversampled rate (drive 10ms, others 5ms)
- Gate state machine (see below)

**Signal chain in process()** (per CONTEXT.md locked order):
1. Apply noise gate (if enabled) — custom gate with hysteresis, operates at original rate pre-distortion
2. `oversampling.processSamplesUp(inputBlock)` — upsample 2x
3. Per-sample loop over oversampled block, per channel:
   a. Read smoothed drive, symmetry, tightness, sag values
   b. Map tightness to cutoff: `20.0f + tightness * 780.0f` (20-800 Hz per CONTEXT.md) — set on `coreState[ch].tightnessFilter`
   c. Map drive: `FuzzConfig::mapDrive(drive)` (1x-40x)
   d. `FuzzCore::processSample(sample, mappedDrive, symmetry, sag, coreState[ch])`
   e. `sample *= FuzzConfig::outputCompensation` (0.30f)
4. `oversampling.processSamplesDown(outputBlock)` — downsample back
5. `tone.applyTone(buffer, toneValue, presenceValue)` — at original rate, after downsampling

**Noise gate with hysteresis (custom implementation, NOT juce::dsp::NoiseGate):**

Implement a simple envelope-follower gate state machine (~30-40 lines):
- Envelope follower: first-order IIR on absolute sample values, per channel (attack coeff ~1ms, release coeff ~80ms per CONTEXT.md discretion)
- State: `gateIsOpen` bool per channel
- Dual threshold: if closed AND envelope > openThreshold, transition to open. If open AND envelope < closeThreshold (openThreshold - hysteresis), transition to close.
- Gain application: `juce::SmoothedValue<float>` per channel ramping between 1.0 (open) and `rangeLinear` (from range dB, default -60 dB = ~0.001) over attack/release time
- Sidechain HPF: `juce::dsp::FirstOrderTPTFilter<float>` per channel, highpass at 150 Hz default, applied to the sidechain signal (level detection path only, NOT to the audio path)
- Default values (Claude's discretion per CONTEXT.md):
  - Attack: 1 ms
  - Release: 80 ms
  - Sidechain HPF: 150 Hz
  - Range: -60 dB
  - Hysteresis: 4 dB

**Sag gain-neutrality (per CONTEXT.md):**
After calling `FuzzCore::processSample()`, apply sag makeup gain. Start with: `sample *= (1.0f + sag * 0.5f)` as a simple linear compensation. This is at Claude's discretion — the exact factor will be tuned empirically. The goal is that sweeping Sag from 0 to 1 at fixed Drive does not noticeably change output level.

**OutputLimiter.h** — Thin wrapper around `juce::dsp::Limiter<float>`:
- `void prepare(const juce::dsp::ProcessSpec& spec)` — forwards to inner limiter, sets threshold to 0 dB, release to 100ms
- `void process(juce::AudioBuffer<float>& buffer)` — wraps buffer in AudioBlock and ProcessContextReplacing, calls limiter.process()
- `void reset()` — forwards to inner limiter

Update CMakeLists.txt to add the new source files to `target_sources`:
- Source/dsp/ClaymoreEngine.cpp (the only new .cpp)
- Header-only files don't need to be listed but can be for IDE visibility

Do NOT run FuzzTone at oversampled rate. Do NOT place noise gate after distortion. Do NOT allocate inside process().
  </action>
  <verify>
    <automated>cd /Users/nathanmcmillan/Projects/Claymore && cmake --build build --config Debug --target Claymore_VST3 2>&1 | tail -10</automated>
    <manual>Project compiles with all new DSP files; no linker errors</manual>
  </verify>
  <done>ClaymoreEngine processes audio through gate -> oversample -> fuzz -> downsample -> tone chain; noise gate has dual-threshold hysteresis; OutputLimiter wraps juce::dsp::Limiter; Tightness HPF maps 20-800 Hz; all classes compile cleanly</done>
</task>

</tasks>

<verification>
1. All seven new files exist under Source/dsp/
2. Project compiles without errors after adding new sources to CMakeLists.txt
3. FuzzCore.h is byte-identical to GunkLord original (no logic changes)
4. FuzzTone.h has exactly one line changed (Tone cutoff range)
5. ClaymoreEngine signal chain order matches CONTEXT.md: gate -> tightness -> drive+clip -> tone -> presence -> sag
6. Noise gate implements dual-threshold hysteresis (separate open/close thresholds)
7. Tightness maps to 20-800 Hz (not GunkLord's 20-300 Hz)
</verification>

<success_criteria>
- All ported fuzz DSP compiles against JUCE 8.0.12 headers
- ClaymoreEngine has prepare(), process(), getLatencyInSamples() public interface
- Noise gate state machine has configurable threshold, attack, release, sidechain HPF, range, and hysteresis
- OutputLimiter wraps juce::dsp::Limiter with 0 dB threshold
- Signal chain order matches the locked CONTEXT.md decision exactly
- No allocations in process() — all buffers pre-allocated in prepare()
</success_criteria>

<output>
After completion, create `.planning/phases/01-dsp-foundation/01-02-SUMMARY.md`
</output>
