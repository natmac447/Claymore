---
phase: 01-dsp-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-02
files_modified:
  - Source/PluginProcessor.h
  - Source/PluginProcessor.cpp
  - CMakeLists.txt
autonomous: true
requirements:
  - SIG-01
  - SIG-02
  - SIG-03
  - SIG-04
  - SIG-05

must_haves:
  truths:
    - "Input Gain scales the signal before distortion across -24 to +24 dB range"
    - "Output Gain scales the signal after dry/wet mix across -48 to +12 dB range"
    - "Dry/Wet Mix blends processed and unprocessed signal with latency-compensated dry path"
    - "Brickwall limiter prevents digital overs on extreme settings"
    - "Noise gate threshold parameter controls gate open/close behavior pre-distortion"
    - "Plugin loads in a DAW host and produces audibly distorted audio"
    - "All parameter changes are heard in real time via the generic DAW editor"
  artifacts:
    - path: "Source/PluginProcessor.cpp"
      provides: "Complete processBlock wiring: input gain -> dry capture -> engine -> mix -> output gain -> limiter"
      contains: "engine.process"
    - path: "Source/PluginProcessor.h"
      provides: "ClaymoreEngine, DryWetMixer, OutputLimiter instances as private members"
      contains: "ClaymoreEngine"
  key_links:
    - from: "Source/PluginProcessor.cpp"
      to: "Source/dsp/ClaymoreEngine.h"
      via: "engine.process() called in processBlock"
      pattern: "engine\\.process"
    - from: "Source/PluginProcessor.cpp"
      to: "Source/dsp/OutputLimiter.h"
      via: "limiter.process() called after output gain"
      pattern: "limiter\\.process"
    - from: "Source/PluginProcessor.cpp"
      to: "Source/Parameters.h"
      via: "cached atomic param pointers read in processBlock"
      pattern: "driveParam->load"
---

<objective>
Wire the complete processBlock signal chain: read all APVTS parameters, drive the ClaymoreEngine, DryWetMixer, and OutputLimiter, and verify the plugin produces correctly distorted audio when loaded in a DAW host.

Purpose: This is the final integration step. Plans 01 and 02 created the parameter contract and DSP engine separately. This plan connects them so the plugin actually works.
Output: A fully functional distortion plugin (no custom GUI) that loads in a DAW and produces audio through all signal chain stages.
</objective>

<execution_context>
@/Users/nathanmcmillan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanmcmillan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dsp-foundation/01-CONTEXT.md
@.planning/phases/01-dsp-foundation/01-RESEARCH.md
@.planning/phases/01-dsp-foundation/01-01-SUMMARY.md
@.planning/phases/01-dsp-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire processBlock with complete signal chain and all parameter connections</name>
  <files>
Source/PluginProcessor.h
Source/PluginProcessor.cpp
  </files>
  <action>
Update PluginProcessor to instantiate and drive all DSP components through the complete signal chain.

**Add to PluginProcessor.h private members:**
- `ClaymoreEngine engine;`
- `juce::dsp::DryWetMixer<float> dryWetMixer { 64 };` (64-sample dry buffer capacity)
- `OutputLimiter limiter;`
- `juce::SmoothedValue<float> inputGainSmoother, outputGainSmoother;` (for zipper-free gain changes)

**Update prepareToPlay():**
1. Create `juce::dsp::ProcessSpec spec { sampleRate, (uint32)samplesPerBlock, (uint32)getTotalNumOutputChannels() }`
2. `engine.prepare(spec)` — initializes all DSP at correct rates
3. `dryWetMixer.prepare(spec)`
4. `dryWetMixer.setWetLatency(engine.getLatencyInSamples())` — compensates for oversampling latency on dry path
5. `setLatencySamples(static_cast<int>(std::ceil(engine.getLatencyInSamples())))` — report to DAW for PDC
6. `limiter.prepare(spec)`
7. `inputGainSmoother.reset(sampleRate, 0.010)` — 10ms smoothing
8. `outputGainSmoother.reset(sampleRate, 0.010)`
9. Cache all atomic param pointers (if not already done in Plan 01's stub)
10. Set `isInitialized = true` LAST

**Implement processBlock() — exact signal chain per CONTEXT.md locked order:**

```
1. [isInitialized guard] — buffer.clear() + return if false
2. Read all parameter values from cached atomic pointers (relaxed memory order)
3. Set engine parameters: engine.setDrive(), setSymmetry(), setTightness(), setSag(), setTone(), setPresence(), setGateEnabled(), setGateThreshold()
4. [Input Gain] — per-sample loop: inputGainSmoother.setTargetValue(juce::Decibels::decibelsToGain(inputGainDb)); for each sample, multiply by inputGainSmoother.getNextValue()
5. [DryWetMixer push dry] — dryWetMixer.setWetMixProportion(mixValue); dryWetMixer.pushDrySamples(juce::dsp::AudioBlock<float>(buffer))
6. [ClaymoreEngine process] — engine.process(buffer)  // gate -> oversample -> fuzz -> downsample -> tone
7. [DryWetMixer mix wet] — dryWetMixer.mixWetSamples(juce::dsp::AudioBlock<float>(buffer))
8. [Output Gain] — per-sample loop: outputGainSmoother.setTargetValue(juce::Decibels::decibelsToGain(outputGainDb)); for each sample, multiply by outputGainSmoother.getNextValue()
9. [OutputLimiter] — limiter.process(buffer)
```

**Important implementation details:**
- Input/Output gain use SmoothedValue for zipper-free automation. Set target ONCE before the sample loop, then call getNextValue() per sample.
- dryWetMixer.setWetMixProportion() takes 0-1 (matches the Mix parameter range directly).
- The isInitialized guard prevents crashes when hosts call processBlock before prepareToPlay (FL Studio Patcher edge case).
- Do NOT read parameters via string lookup inside processBlock. Use the cached `std::atomic<float>*` pointers from prepareToPlay.
- All gain conversions use `juce::Decibels::decibelsToGain()` (NOT manual pow/exp).

**Add includes in PluginProcessor.h:**
- `#include "dsp/ClaymoreEngine.h"`
- `#include "dsp/OutputLimiter.h"`

**Update releaseResources():**
- `dryWetMixer.reset()`
- `limiter.reset()`
  </action>
  <verify>
    <automated>cd /Users/nathanmcmillan/Projects/Claymore && cmake --build build --config Debug --target Claymore_VST3 2>&1 | tail -10</automated>
    <manual>Build succeeds with all wiring in place</manual>
  </verify>
  <done>processBlock implements the complete signal chain: input gain -> dry capture -> engine (gate->fuzz->tone) -> wet mix -> output gain -> limiter; all 11 parameters read from cached atomic pointers; SmoothedValue on gains prevents zipper noise</done>
</task>

<task type="auto">
  <name>Task 2: Build Release, install plugin, and verify it loads</name>
  <files>
CMakeLists.txt
  </files>
  <action>
1. If CMakeLists.txt needs any source file additions from Plan 02 that weren't already added, update `target_sources` now (ClaymoreEngine.cpp).

2. Build Release configuration for both targets:
   ```bash
   cmake --build build --config Release --target Claymore_VST3
   cmake --build build --config Release --target Claymore_AU
   ```

3. Verify binaries exist:
   ```bash
   find build -name "*.vst3" -type d
   find build -name "*.component" -type d
   ```

4. Verify the VST3 bundle structure is valid:
   ```bash
   ls -la build/Claymore_artefacts/Release/VST3/Claymore.vst3/Contents/
   ```

5. Check the binary is Universal (arm64 + x86_64):
   ```bash
   lipo -info build/Claymore_artefacts/Release/VST3/Claymore.vst3/Contents/MacOS/Claymore
   ```
   (Path may vary — adjust based on actual build output structure)

6. Run a basic smoke test using JUCE's validation approach — check the plugin binary loads without immediate crash:
   ```bash
   file build/Claymore_artefacts/Release/VST3/Claymore.vst3/Contents/MacOS/Claymore
   ```

Note: Full DAW load testing and auval are deferred to Phase 4 (Validation). Phase 1 success criteria require the plugin to build and produce a valid binary. The user will manually load it in their DAW to verify audio processing.
  </action>
  <verify>
    <automated>cd /Users/nathanmcmillan/Projects/Claymore && cmake --build build --config Release --target Claymore_VST3 2>&1 | tail -5 && echo "---" && find build -name "Claymore.vst3" -type d</automated>
    <manual>Release build succeeds; VST3 bundle exists at expected path</manual>
  </verify>
  <done>Plugin builds in Release for VST3 and AU; binary exists and is a valid Universal Binary; ready for user to load in DAW</done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Release` succeeds for both VST3 and AU
2. processBlock signal chain order matches CONTEXT.md: Input Gain -> Dry Capture -> Gate -> Tightness -> Drive+Clip -> Tone -> Presence -> Sag -> Downsample -> Wet Mix -> Output Gain -> Limiter
3. All 11 cached atomic param pointers are read in processBlock
4. Input/Output gain use SmoothedValue (no zipper noise)
5. DryWetMixer has wet latency set from engine.getLatencyInSamples()
6. setLatencySamples() called in prepareToPlay for DAW PDC
7. VST3 and AU bundles exist in build output
</verification>

<success_criteria>
- Plugin compiles and builds in Release without warnings
- Complete signal chain wired in processBlock matching CONTEXT.md order
- All parameters audibly affect the output when adjusted in DAW generic editor
- Input Gain, Output Gain, and Mix work as expected
- Brickwall limiter prevents digital overs
- Noise gate opens/closes based on threshold setting
- Plugin reports correct latency to DAW
- VST3 and AU binaries produced
</success_criteria>

<output>
After completion, create `.planning/phases/01-dsp-foundation/01-03-SUMMARY.md`
</output>
