---
phase: 02-selectable-oversampling
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - Source/Parameters.h
  - Source/dsp/ClaymoreEngine.h
  - Source/PluginProcessor.h
  - Source/PluginProcessor.cpp
autonomous: true
requirements:
  - QUAL-01
  - QUAL-02

must_haves:
  truths:
    - "User can select oversampling rate (2x, 4x, 8x) as a DAW-automatable parameter"
    - "Switching oversampling rate mid-playback does not cause audio dropout, glitch, or DAW crash"
    - "Plugin reports correct latency to DAW at all three oversampling rates"
    - "Dry/wet mix remains phase-aligned after switching oversampling rates"
    - "Parameter smoothers operate at the correct oversampled rate after a rate switch"
  artifacts:
    - path: "Source/Parameters.h"
      provides: "AudioParameterChoice for oversampling selector (2x, 4x, 8x)"
      contains: "ParamIDs::oversampling"
    - path: "Source/dsp/ClaymoreEngine.h"
      provides: "Pre-allocated array of 3 Oversampling objects, setOversamplingFactor(), updated getLatencyInSamples()"
      contains: "oversamplingObjects"
    - path: "Source/PluginProcessor.h"
      provides: "Oversampling param pointer, lastOversamplingIndex tracker, DryWetMixer capacity 256"
      contains: "dryWetMixer { 256 }"
    - path: "Source/PluginProcessor.cpp"
      provides: "Per-block rate change detection, latency re-sync on switch"
      contains: "setOversamplingFactor"
  key_links:
    - from: "Source/PluginProcessor.cpp"
      to: "Source/dsp/ClaymoreEngine.h"
      via: "engine.setOversamplingFactor(newIndex) called when APVTS oversampling param changes"
      pattern: "engine\\.setOversamplingFactor"
    - from: "Source/PluginProcessor.cpp"
      to: "dryWetMixer.setWetLatency"
      via: "Re-sync DryWetMixer latency after oversampling rate change"
      pattern: "dryWetMixer\\.setWetLatency.*engine\\.getLatencyInSamples"
    - from: "Source/PluginProcessor.cpp"
      to: "setLatencySamples"
      via: "Report new latency to DAW host after oversampling rate change"
      pattern: "setLatencySamples.*std::round.*engine\\.getLatencyInSamples"
    - from: "Source/dsp/ClaymoreEngine.h"
      to: "oversamplingObjects[currentOversamplingIndex]"
      via: "process() selects active oversampling stage by index"
      pattern: "oversamplingObjects\\[currentOversamplingIndex\\]"
---

<objective>
Upgrade ClaymoreEngine from hardcoded 2x oversampling to selectable 2x/4x/8x with correct DAW latency reporting and DryWetMixer phase alignment at all rates.

Purpose: Delivers QUAL-01 (user selects oversampling rate) and QUAL-02 (correct latency to DAW), enabling the CPU-vs-quality tradeoff that makes Claymore practical for mixing sessions with many instances.

Output: Modified ClaymoreEngine with pre-allocated oversampling array, new APVTS oversampling parameter, per-block rate change detection in PluginProcessor, Release build with selectable oversampling functional.
</objective>

<execution_context>
@/Users/nathanmcmillan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanmcmillan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-selectable-oversampling/02-RESEARCH.md
@.planning/phases/01-dsp-foundation/01-02-SUMMARY.md
@.planning/phases/01-dsp-foundation/01-03-SUMMARY.md
@Source/dsp/ClaymoreEngine.h
@Source/Parameters.h
@Source/PluginProcessor.h
@Source/PluginProcessor.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add oversampling parameter and upgrade ClaymoreEngine to pre-allocated 2x/4x/8x array</name>
  <files>Source/Parameters.h, Source/dsp/ClaymoreEngine.h</files>
  <action>
**Parameters.h changes:**

1. Add `oversampling` to the `ParamIDs` namespace:
   ```cpp
   inline constexpr const char* oversampling = "oversampling";
   ```

2. Add `AudioParameterChoice` to `createParameterLayout()` (after the `gateThreshold` entry, before `return layout`):
   ```cpp
   layout.add(std::make_unique<juce::AudioParameterChoice>(
       juce::ParameterID { ParamIDs::oversampling, 1 },
       "Oversampling",
       juce::StringArray { "2x", "4x", "8x" },
       0  // default: 2x (index 0)
   ));
   ```

**ClaymoreEngine.h changes:**

1. Replace the single `juce::dsp::Oversampling<float> oversampling` member with:
   ```cpp
   static constexpr int numOversamplingFactors = 3; // 2x, 4x, 8x
   std::array<std::unique_ptr<juce::dsp::Oversampling<float>>, numOversamplingFactors> oversamplingObjects;
   int currentOversamplingIndex = 0; // 0=2x, 1=4x, 2=8x
   ```
   Add `#include <array>` and `#include <memory>` at the top if not already present (juce headers likely pull these in, but be explicit).

2. Update the constructor: remove the `oversampling(2, 1, ...)` initializer list entry. The `oversamplingObjects` array is default-initialized (unique_ptrs to nullptr); objects are created in `prepare()`.

3. Update `prepare()`:
   - Remove the old `oversampling.initProcessing(...)` and `oversampling.reset()` lines.
   - Add the pre-allocation loop (from RESEARCH.md Pattern 1):
     ```cpp
     for (int i = 0; i < numOversamplingFactors; ++i)
     {
         oversamplingObjects[i] = std::make_unique<juce::dsp::Oversampling<float>>(
             static_cast<size_t>(numChannels),
             static_cast<size_t>(i + 1),  // 1=2x, 2=4x, 3=8x
             juce::dsp::Oversampling<float>::filterHalfBandPolyphaseIIR,
             true,   // isMaxQuality
             false   // useIntegerLatency (consistent with Phase 1)
         );
         oversamplingObjects[i]->initProcessing(static_cast<size_t>(spec.maximumBlockSize));
     }
     ```
   - Update the oversampled rate calculation for FuzzCoreState and smoothers: replace `const double oversampledRate = sampleRate * 2.0;` with:
     ```cpp
     const double oversampledRate = sampleRate * std::pow(2.0, currentOversamplingIndex + 1);
     ```
   - Store `maxBlockSize` as a member (`int maxBlockSize = 512;`) for use if `setOversamplingFactor` needs to reference it later (not strictly required since objects are pre-allocated, but keep for documentation).

4. Update `process()`:
   - Replace `auto oversampledBlock = oversampling.processSamplesUp(block);` with:
     ```cpp
     auto& os = *oversamplingObjects[currentOversamplingIndex];
     auto oversampledBlock = os.processSamplesUp(block);
     ```
   - Replace `oversampling.processSamplesDown(block);` with:
     ```cpp
     os.processSamplesDown(block);
     ```

5. Add `setOversamplingFactor()` method (public, after the existing parameter setters):
   ```cpp
   void setOversamplingFactor(int index)
   {
       const int newIndex = juce::jlimit(0, numOversamplingFactors - 1, index);
       if (newIndex == currentOversamplingIndex)
           return;

       // Reset the OLD oversampling object's filter state (Pitfall 3: stale state)
       oversamplingObjects[currentOversamplingIndex]->reset();

       currentOversamplingIndex = newIndex;

       // Recalculate oversampled rate for smoothers and FuzzCoreState (Pitfall 4)
       const double newOsRate = sampleRate * std::pow(2.0, currentOversamplingIndex + 1);

       driveSmoother.reset(newOsRate, 0.010);
       symmetrySmoother.reset(newOsRate, 0.005);
       tightnessSmoother.reset(newOsRate, 0.005);
       sagSmoother.reset(newOsRate, 0.005);

       // Re-prepare FuzzCoreState at new oversampled rate (Open Question 3)
       for (int ch = 0; ch < maxChannels; ++ch)
           coreState[ch].prepare(newOsRate);
   }
   ```

6. Update `getLatencyInSamples()`:
   ```cpp
   float getLatencyInSamples() const
   {
       return oversamplingObjects[currentOversamplingIndex]->getLatencyInSamples();
   }
   ```

7. Update `reset()`: replace `oversampling.reset();` with:
   ```cpp
   for (int i = 0; i < numOversamplingFactors; ++i)
       if (oversamplingObjects[i])
           oversamplingObjects[i]->reset();
   ```

8. Update the class comment at the top: change "Phase 1 -- fixed 2x oversampling" to "Phase 2 -- selectable 2x/4x/8x oversampling" in the signal chain description.

**Do NOT:**
- Use `useIntegerLatency = true` (keep `false`, consistent with Phase 1 per RESEARCH.md recommendation).
- Call `initProcessing()` anywhere except in `prepare()`.
- Create or destroy Oversampling objects in `process()` or `setOversamplingFactor()`.
  </action>
  <verify>
    <automated>cd /Users/nathanmcmillan/Projects/Claymore && cmake --build build --config Debug 2>&1 | tail -5</automated>
    <manual>Verify ClaymoreEngine.h has oversamplingObjects array (not single oversampling member), setOversamplingFactor method exists, Parameters.h has AudioParameterChoice for oversampling</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    - Parameters.h has ParamIDs::oversampling and AudioParameterChoice with StringArray {"2x", "4x", "8x"} defaulting to index 0
    - ClaymoreEngine.h has std::array of 3 unique_ptr Oversampling objects, all created in prepare()
    - setOversamplingFactor(int) resets old stage, updates index, re-resets smoothers and FuzzCoreState at new oversampled rate
    - getLatencyInSamples() returns latency from currently selected oversampling object
    - Project compiles cleanly in Debug
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire per-block rate-change detection in PluginProcessor and verify Release build</name>
  <files>Source/PluginProcessor.h, Source/PluginProcessor.cpp</files>
  <action>
**PluginProcessor.h changes:**

1. Add oversampling parameter pointer alongside the other cached param pointers:
   ```cpp
   std::atomic<float>* oversamplingParam = nullptr;
   ```

2. Add rate-change tracking member (private, near `isInitialized`):
   ```cpp
   int lastOversamplingIndex = 0;
   ```

3. Change `dryWetMixer { 64 }` to `dryWetMixer { 256 }` (Pitfall 1: capacity must cover 8x IIR latency which can reach ~60 samples at higher sample rates). Update the comment from "64-sample capacity: sufficient for 2x IIR oversampling latency (~4 samples)" to "256-sample capacity: sufficient for 8x IIR oversampling latency (~60 samples max)".

**PluginProcessor.cpp changes:**

1. In the constructor, add the oversampling parameter cache after the gateThreshold line:
   ```cpp
   oversamplingParam = apvts.getRawParameterValue(ParamIDs::oversampling);
   ```

2. In `prepareToPlay()`, after `engine.prepare(spec)`:
   - Read the initial oversampling index and apply it before latency reporting:
     ```cpp
     const int initialOsIndex = static_cast<int>(oversamplingParam->load(std::memory_order_relaxed));
     if (initialOsIndex != 0)
         engine.setOversamplingFactor(initialOsIndex);
     lastOversamplingIndex = initialOsIndex;
     ```
   - Update `setLatencySamples` call to use `std::round` (Pitfall 2: fractional latency):
     ```cpp
     setLatencySamples(static_cast<int>(std::round(engine.getLatencyInSamples())));
     ```
   - Ensure `dryWetMixer.setWetLatency(engine.getLatencyInSamples());` remains after the oversampling factor is set (it already runs after engine.prepare, but must come after the setOversamplingFactor call too).
   - Add `#include <cmath>` at top of .cpp if `std::round` is not already available (JUCE headers may provide it, but be explicit).

3. In `processBlock()`, after the parameter reads block and before step 1 (Input Gain), add per-block rate-change detection (RESEARCH.md Pattern 2):
   ```cpp
   // --- Oversampling rate change detection (QUAL-01, QUAL-02) ---
   {
       const int newOversamplingIndex = static_cast<int>(oversamplingParam->load(std::memory_order_relaxed));
       if (newOversamplingIndex != lastOversamplingIndex)
       {
           lastOversamplingIndex = newOversamplingIndex;
           engine.setOversamplingFactor(newOversamplingIndex);

           const float newLatency = engine.getLatencyInSamples();
           dryWetMixer.setWetLatency(newLatency);
           setLatencySamples(static_cast<int>(std::round(newLatency)));
       }
   }
   ```
   Place this block right after the existing parameter reads (after `const float gateThreshDB = ...`) and before the Input Gain section (step 1).

4. Add the oversampling parameter read alongside the other parameter reads in processBlock:
   (Note: the oversamplingParam is read inside the rate-change detection block above, NOT as a separate `const float` line. It is read directly via `oversamplingParam->load()` in the detection block.)

**Do NOT:**
- Use a timer or message-thread deferral for `setLatencySamples()` — follow the Crucible pattern of calling it directly from processBlock (per RESEARCH.md recommendation). The STATE.md Nuendo re-entrancy concern remains as an empirical verification step, not a design constraint.
- Add any new files. All changes are in the existing 4 files.
- Change the oversampling filter type (keep `filterHalfBandPolyphaseIIR` from Phase 1).

**Release build verification:**
After all code changes compile in Debug, build Release:
```bash
cmake --build build --config Release --target Claymore_VST3
cmake --build build --config Release --target Claymore_AU
```
Verify both build without errors.
  </action>
  <verify>
    <automated>cd /Users/nathanmcmillan/Projects/Claymore && cmake --build build --config Release --target Claymore_VST3 2>&1 | tail -3 && cmake --build build --config Release --target Claymore_AU 2>&1 | tail -3</automated>
    <manual>Verify PluginProcessor.cpp has rate-change detection block with setOversamplingFactor + setWetLatency + setLatencySamples. Verify dryWetMixer capacity is 256 in PluginProcessor.h.</manual>
    <sampling_rate>run after this task commits</sampling_rate>
  </verify>
  <done>
    - PluginProcessor.h has oversamplingParam pointer, lastOversamplingIndex tracker, dryWetMixer { 256 }
    - PluginProcessor.cpp constructor caches oversamplingParam from APVTS
    - PluginProcessor.cpp prepareToPlay reads initial oversampling index and applies it before latency reporting
    - PluginProcessor.cpp processBlock detects oversampling rate change per-block, calls engine.setOversamplingFactor, re-syncs dryWetMixer.setWetLatency and setLatencySamples with std::round
    - Release VST3 and AU build without errors
  </done>
</task>

</tasks>

<verification>
1. `grep -n "oversamplingObjects" Source/dsp/ClaymoreEngine.h` — confirms array member and usage in prepare/process/reset/getLatency
2. `grep -n "ParamIDs::oversampling" Source/Parameters.h Source/PluginProcessor.cpp` — confirms parameter definition and cache
3. `grep -n "setOversamplingFactor" Source/PluginProcessor.cpp Source/dsp/ClaymoreEngine.h` — confirms wiring from processBlock to engine
4. `grep -n "dryWetMixer { 256 }" Source/PluginProcessor.h` — confirms capacity upgrade
5. `grep -n "std::round" Source/PluginProcessor.cpp` — confirms fractional latency rounding (Pitfall 2)
6. `grep -n "setWetLatency" Source/PluginProcessor.cpp` — confirms DryWetMixer re-sync on rate change
7. Release build succeeds for both VST3 and AU targets
</verification>

<success_criteria>
- All 4 source files modified with the oversampling upgrade
- ClaymoreEngine pre-allocates 3 oversampling objects (2x, 4x, 8x) in prepare() with zero allocation in process()
- PluginProcessor detects oversampling rate change per-block and re-syncs DryWetMixer + DAW latency
- DryWetMixer capacity is 256 (sufficient for 8x IIR at high sample rates)
- Fractional latency handled with std::round (not truncation)
- Stale filter state cleared on rate switch (oversamplingObjects[oldIndex]->reset())
- Smoothers and FuzzCoreState re-prepared at new oversampled rate on switch
- Release VST3 and AU build successfully
- QUAL-01 and QUAL-02 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/02-selectable-oversampling/02-01-SUMMARY.md`
</output>
